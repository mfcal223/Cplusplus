# Constructors

A constructor is a special function that runs automatically when an object is created.   
It is used to initialize the object‚Äôs data members (instead of using a separate function like set_value()).  

`Manual initialization: ` 
```cpp
class MyClass {
public:
    int x;
    void set_value(int val) {
        x = val;
    }
};

int main() {
    MyClass obj;
    obj.set_value(42); // manual init
}

```

`Automatic initialization with Constructor:`  

With constructor (automatic init):
```cpp
class MyClass {
public:
    int x;
    MyClass(int val) { // constructor
        x = val;
    }
};

int main() {
    MyClass obj(42); // automatic init
}
```

‚ö†Ô∏è Using a constructor ensures the object is ready to use right after it's created.  

üß± Rules and Features of Constructors

| Rule or Feature                 | Description                                                                                |
| ------------------------------- | ------------------------------------------------------------------------------------------ |
| **Same name as class**          | ‚úÖ Must be exactly the same name. No return type (not even `void`).                         |
| **No return type**              | A constructor **never has a return type**.                                                 |
| **Can be overloaded**           | You can define **multiple constructors** with different parameter lists.                   |
| **Can use initializer lists**   | Preferred way to initialize member variables. Example: `MyClass() : x(5) {}`               |
| **Default constructor**         | A constructor with **no parameters** (either written by you or generated by the compiler). |
| **Constructor with parameters** | Used for setting custom values during object creation.                                     |
| **Copy constructor**            | Special constructor: `MyClass(const MyClass& other)`                                       |
| **Destructor counterpart**      | Automatically called when the object is destroyed. Syntax: `~MyClass()`                    |

EXAMPLE:  

```cpp
class Person {
private:
    std::string name;
    int age;

public:
    // 1. Default constructor
    Person() {
        name = "Unknown";
        age = 0;
    }

    // 2. Constructor with parameters
    Person(std::string n, int a) {
        name = n;
        age = a;
    }

    // 3. Using initializer list (better style)
    Person(std::string n, int a) : name(n), age(a) {}

    void introduce() {
        std::cout << "I'm " << name << ", " << age << " years old.\n";
    }
};

```

How you would use them:

```cpp
Person a;                      // calls default constructor
Person b("Maria", 28);         // calls parameter constructor
```

‚ùó Constructor Mistakes to Avoid
| Mistake                       | Example                            | Why it's wrong                                                          |
| ----------------------------- | ---------------------------------- | ----------------------------------------------------------------------- |
| Adding return type            | `int MyClass() {}`                 | ‚ùå Constructors don‚Äôt return anything                                    |
| Wrong name                    | `Myclass(int x) {}`                | ‚ùå Must match class name exactly (case-sensitive)                        |
| Forgetting parentheses        | `MyClass obj;` vs `MyClass obj();` | ‚ùó `MyClass obj();` is a function declaration, not an object!            |
| Relying only on `set_value()` | `obj.set_value(x);`                | ‚ùó Manual, error-prone, doesn‚Äôt guarantee object is valid after creation |

---
## Constructor Overloading  

Constructor overloading means that you can define multiple constructors in the same class, as long as they have different parameter lists.
This allows you to create objects in different ways, depending on the data you have.

Each constructor must have a unique parameter signature (number or types of parameters).
The compiler chooses the right constructor based on how you call it.

üß™Example:

- Class + constructor: 
```cpp
class Book {
private:
    std::string title;
    int pages;

public:
    // Default constructor
    Book() {
        title = "Untitled";
        pages = 0;
    }

    // Constructor with 1 parameter
    Book(std::string t) {
        title = t;
        pages = 100; // default
    }

    // Constructor with 2 parameters
    Book(std::string t, int p) {
        title = t;
        pages = p;
    }

    void print() {
        std::cout << title << " (" << pages << " pages)\n";
    }
};

```

- Usage:
```cpp
Book a;                   // uses Book()
Book b("C++ for Dummies"); // uses Book(std::string)
Book c("The Art of C++", 350); // uses Book(std::string, int)
```

---
## Initialization lists
An initializer list is the preferred way to initialize class attributes when you define a constructor.  
- Initializes before constructor runs.  
- Works with const members.  
- Works with reference members.
- More efficient for complex types.

Example 1:
```cpp
class Person {
private:
    std::string name;
public:
    Person(std::string n) : name(n) {} // initializer list
};
```

Example 2:
```cpp
class Car {
private:
    std::string brand;
    int year;
public:
    // Using initializer list
    Car(std::string b, int y) : brand(b), year(y) {}
    
    void print() {
        std::cout << brand << " from " << year << std::endl;
    }
};
```

This is equivalent to writing:

```cpp
Car(std::string b, int y) {
    brand = b;
    year = y;
}
```
---

## What does "explicit" mean?
Sometimes when declaring the constructor in a header file, you will see the word explicit before the constructor's name:

```cpp
explicit Weapon(const std::string& type);
```
This prevents implicit conversions from happening. Without explicit, you could accidentally write:

```cpp
Weapon w = "club";  // implicit conversion from const char* to std::string, then Weapon
```

With explicit, you must write it explicitly:  

```cpp
Weapon w("club");
```

So explicit makes the constructor safer and avoids surprises.  

Let‚Äôs do a before/after demo so you see what explicit changes.

Case 1 ‚Äî Constructor without explicit
class Weapon {
private:
    std::string type;
public:
    Weapon(const std::string& t) : type(t) {}
    const std::string& getType() const { return type; }
};


Now in main:

int main() {
    Weapon w1 = "club";    // ‚úÖ works! implicit conversion
    std::cout << w1.getType() << std::endl;

    return 0;
}


Why does this compile?

"club" is a string literal (const char*).

It gets converted to a temporary std::string.

That temporary is passed into Weapon(const std::string&).

So the compiler automatically builds a Weapon for you.

This can be convenient, but also dangerous if it happens by accident.

Case 2 ‚Äî Constructor with explicit
class Weapon {
private:
    std::string type;
public:
    explicit Weapon(const std::string& t) : type(t) {}
    const std::string& getType() const { return type; }
};


Now in main:

int main() {
    Weapon w1 = "club";    // ‚ùå ERROR: no implicit conversion allowed
    Weapon w2("club");     // ‚úÖ must call constructor explicitly
    std::cout << w2.getType() << std::endl;

    return 0;
}


Here the compiler refuses Weapon w1 = "club"; because that would require an implicit conversion from const char* ‚Üí std::string ‚Üí Weapon.
Since the constructor is explicit, you must write it directly: Weapon("club").

Why this matters

explicit avoids surprising constructions when your class is used in bigger programs.

Without it, something like this could happen silently:

void fight(Weapon w);

fight("rock");  // without explicit: OK, auto-converts to Weapon
                // with explicit: ERROR, forces you to write fight(Weapon("rock"));


‚úÖ So the takeaway:  
No explicit ‚Üí more convenient, but implicit conversions might sneak in.  
With explicit ‚Üí safer, forces clarity in code.  

Rule of thumb

Always consider explicit for constructors with one argument (especially if that argument is a type the compiler could convert into easily, like const char* ‚Üí std::string).

For constructors with multiple arguments, explicit is usually unnecessary.

---

# Destructors

Destructors are the natural counterpart to constructors as they are a special function in a class that gets called automatically when an object is destroyed.
Think of a destructor like the cleanup phase for a malloc-allocated object‚Äîbut automatic and tied to object scope.  
- It‚Äôs used to free resources (like dynamic memory, file handles, etc.)
- You define it with a ~ followed by the class name.
- It has no parameters, no return type, and you can‚Äôt overload it.  

üîê `Destructor Syntax`

```cpp
class MyClass {
public:
    ~MyClass(); // Declaration
};
```

If you don‚Äôt define a destructor, C++ automatically gives you a default one that just does nothing‚Äîunless you‚Äôre dealing with pointers or resource handles.

‚úÖ  Example:
```cpp
#include <iostream>
class Test {
public:
    Test() {
        std::cout << "Constructor called\n";
    }

    ~Test() {
        std::cout << "Destructor called\n";
    }
};

int main() {
    Test t;
    // Constructor runs here
    // ...
    // Destructor runs automatically when `t` goes out of scope
}
```

üü¢ Output:

```yaml
Constructor called
Destructor called
```

‚úÖ  Example ‚ö†Ô∏è With Dynamic Memory
```cpp
class MyClass {
private:
    int* data;
public:
    MyClass() {
        data = new int[10]; // Allocate
    }

    ~MyClass() {
        delete[] data;      // Free
    }
};
```

üí° Without the destructor, that memory would leak.